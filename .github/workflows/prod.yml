name: Prod Pipeline

on:
  workflow_dispatch:
  push:
    branches:
      - prod

jobs:
  run-tests:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run pytest suite
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
        run: pytest

      - name: Apply label to associated PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = 'test passed';
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    ...context.repo,
                    name: labelName,
                    color: labelColor,
                    description: 'Prod pipeline tests succeeded',
                  });
                } else {
                  throw error;
                }
              }
            }
            await ensureLabelExists();
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: pr.number,
                labels: [labelName],
              });
              core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
            }

  bump-version:
    name: Bump Version
    needs: run-tests
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
      changed: ${{ steps.bump_version.outputs.changed }}
      branch: ${{ steps.bump_version.outputs.branch }}
      bump_type: ${{ steps.bump_version.outputs.bump_type }}
      target_ref: ${{ steps.bump_version.outputs.target_ref }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump version
        id: bump_version
        run: |
          set -euo pipefail
          trig_branch="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"
          target_ref="${GITHUB_REF_NAME:-${GITHUB_HEAD_REF}}"
          if [[ -z "$target_ref" ]]; then
            target_ref="$trig_branch"
          fi
          source_branch="$trig_branch"
          git fetch --no-tags --prune origin "+refs/heads/*:refs/remotes/origin/*"
          if git merge-base --is-ancestor "$GITHUB_SHA" origin/main 2>/dev/null; then
            source_branch="main"
          else
            while IFS= read -r remote; do
              if git merge-base --is-ancestor "$GITHUB_SHA" "$remote" 2>/dev/null; then
                source_branch="${remote#origin/}"
                break
              fi
            done < <(git for-each-ref --format='%(refname:short)' 'refs/remotes/origin/hotfix/*')
          fi
          echo "Trigger branch: ${trig_branch}"
          echo "Detected source branch: ${source_branch}"
          echo "Target ref: ${target_ref}"
          if [[ ! -f version ]]; then
            echo "Version file not found." >&2
            exit 1
          fi
          current_version=$(tr -d '\n\r ' < version)
          if [[ -z "$current_version" ]]; then
            echo "Version file is empty." >&2
            exit 1
          fi
          IFS='.' read -r major minor patch <<<"$current_version"
          new_version="$major.$minor.$patch"
          bump_type="none"
          changed="false"
          if [[ "$source_branch" == "main" ]]; then
            minor=$((minor + 1))
            patch=0
            new_version="$major.$minor.$patch"
            bump_type="minor"
          elif [[ "$source_branch" == hotfix/* ]]; then
            patch=$((patch + 1))
            new_version="$major.$minor.$patch"
            bump_type="patch"
          else
            echo "Branch ${source_branch} does not require a version bump."
          fi
          if [[ "$new_version" != "$current_version" ]]; then
            echo "$new_version" > version
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add version
            if ! git diff --cached --quiet; then
              git commit -m "chore: bump version to $new_version"
              git push origin "HEAD:${target_ref}"
              echo "Version bumped from $current_version to $new_version ($bump_type)."
              changed="true"
            else
              echo "No changes detected after bump."
            fi
          else
            echo "Version remains $new_version."
          fi
          {
            echo "new_version=$new_version"
            echo "changed=$changed"
            echo "branch=$source_branch"
            echo "bump_type=$bump_type"
            echo "target_ref=$target_ref"
          } >> "$GITHUB_OUTPUT"

      - name: Apply release label to associated PRs
        if: steps.bump_version.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const newVersion = '${{ steps.bump_version.outputs.new_version }}';
            if (!newVersion) {
              core.info('No new version detected, skipping label creation.');
              return;
            }
            const labelName = `release: ${newVersion}`;
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    ...context.repo,
                    name: labelName,
                    color: labelColor,
                    description: `Release ${newVersion}`,
                  });
                } else {
                  throw error;
                }
              }
            }
            await ensureLabelExists();
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: pr.number,
                labels: [labelName],
              });
              core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
            }

  generate-changelog:
    name: Generate Changelog
    needs: bump-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      SOURCE_BRANCH: ${{ needs.bump-version.outputs.branch }}
      TARGET_REF: ${{ needs.bump-version.outputs.target_ref }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Prepare changelog entry
        id: changelog
        env:
          DESCRIPTION_PATH: scripts/changelog/description.txt
        run: |
          set -euo pipefail
          branch="${SOURCE_BRANCH:-${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}}"
          target_ref="${TARGET_REF:-${GITHUB_REF_NAME:-${GITHUB_HEAD_REF}}}"
          if [[ -z "$target_ref" ]]; then
            target_ref="${GITHUB_REF_NAME:-${GITHUB_HEAD_REF:-$branch}}"
          fi
          echo "Detected branch: ${branch}"
          echo "Target ref: ${target_ref}"
          if [[ ! -f "version" ]]; then
            echo "Version file not found." >&2
            exit 1
          fi
          new_version=$(tr -d '\n\r ' < version)
          if [[ -z "$new_version" ]]; then
            echo "Version file is empty." >&2
            exit 1
          fi
          hotfix_arg=()
          if [[ "$branch" == hotfix/* ]]; then
            hotfix_arg=(--hotfix)
          fi
          if [[ ! -s "$DESCRIPTION_PATH" ]]; then
            echo "Description file is empty. Populate ${DESCRIPTION_PATH} before running the workflow." >&2
            exit 1
          fi
          python scripts/changelog/generate_changelog.py --clear-description-file "${hotfix_arg[@]}"
          changed="false"
          if ! git diff --exit-code --quiet changelog.md "$DESCRIPTION_PATH"; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add changelog.md "$DESCRIPTION_PATH"
            if ! git diff --cached --quiet; then
              git commit -m "docs: update changelog for ${new_version}"
              git push origin "HEAD:${target_ref}"
              changed="true"
              echo "Changelog updated and pushed for ${new_version}."
            fi
          else
            echo "No changelog updates detected."
          fi
          {
            echo "changed=$changed"
            echo "branch=$branch"
            echo "new_version=$new_version"
          } >> "$GITHUB_OUTPUT"

      - name: Apply changelog label to associated PRs
        if: steps.changelog.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = 'changelog updated';
            const labelColor = '5319E7';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    ...context.repo,
                    name: labelName,
                    color: labelColor,
                    description: 'Changelog entry generated automatically',
                  });
                } else {
                  throw error;
                }
              }
            }
            await ensureLabelExists();
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: pr.number,
                labels: [labelName],
              });
              core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
            }

  publish-docker-image:
    name: Publish Docker Image
    needs:
      - bump-version
      - generate-changelog
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ format('igor/{0}:{1}', lower(github.event.repository.name), needs.bump-version.outputs.new_version) }}

      - name: Apply docker label to associated PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = '${{ needs.bump-version.outputs.new_version }}';
            if (!version) {
              core.info('Version is not available, skipping docker label application.');
              return;
            }
            const repositoryName = context.repo.repo.toLowerCase();
            const imageTag = `igor/${repositoryName}:${version}`;
            const labelName = 'docker image published';
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    ...context.repo,
                    name: labelName,
                    color: labelColor,
                    description: `Docker image ${imageTag} pushed`,
                  });
                } else {
                  throw error;
                }
              }
            }
            await ensureLabelExists();
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: pr.number,
                labels: [labelName],
              });
              core.info(`Label "${labelName}" applied to PR #${pr.number} for image ${imageTag}.`);
            }

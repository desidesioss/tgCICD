name: Prod Pipeline

on:
  workflow_dispatch:
  push:
    branches:
      - prod

jobs:
  run-tests:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run pytest suite
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
        run: pytest

      - name: Apply label to associated PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = 'test passed';
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
                return true;
              } catch (error) {
                if (error.status === 404) {
                  try {
                    await github.rest.issues.createLabel({
                      ...context.repo,
                      name: labelName,
                      color: labelColor,
                      description: 'Prod pipeline tests succeeded',
                    });
                    return true;
                  } catch (creationError) {
                    if (creationError.status === 403) {
                      core.warning(`Insufficient permissions to create label "${labelName}". Skipping step.`);
                      return false;
                    }
                    throw creationError;
                  }
                }
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to access label "${labelName}". Skipping step.`);
                  return false;
                }
                throw error;
              }
            }
            const labelAvailable = await ensureLabelExists();
            if (!labelAvailable) {
              return;
            }
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: [labelName],
                });
                core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
              } catch (error) {
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to label PR #${pr.number}, skipping.`);
                  continue;
                }
                throw error;
              }
            }

  bump-version:
    name: Bump Version
    needs: run-tests
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
      changed: ${{ steps.bump_version.outputs.changed }}
      branch: ${{ steps.bump_version.outputs.branch }}
      bump_type: ${{ steps.bump_version.outputs.bump_type }}
      target_ref: ${{ steps.bump_version.outputs.target_ref }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump version
        id: bump_version
        run: |
          set -euo pipefail
          trig_branch="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"
          target_ref="${GITHUB_REF_NAME:-${GITHUB_HEAD_REF}}"
          if [[ -z "$target_ref" ]]; then
            target_ref="$trig_branch"
          fi
          source_branch="$trig_branch"
          git fetch --no-tags --prune origin "+refs/heads/*:refs/remotes/origin/*"
          if git merge-base --is-ancestor "$GITHUB_SHA" origin/main 2>/dev/null; then
            source_branch="main"
          else
            while IFS= read -r remote; do
              if git merge-base --is-ancestor "$GITHUB_SHA" "$remote" 2>/dev/null; then
                source_branch="${remote#origin/}"
                break
              fi
            done < <(git for-each-ref --format='%(refname:short)' 'refs/remotes/origin/hotfix/*')
          fi
          echo "Trigger branch: ${trig_branch}"
          echo "Detected source branch: ${source_branch}"
          echo "Target ref: ${target_ref}"
          if [[ ! -f version ]]; then
            echo "Version file not found." >&2
            exit 1
          fi
          current_version=$(tr -d '\n\r ' < version)
          if [[ -z "$current_version" ]]; then
            echo "Version file is empty." >&2
            exit 1
          fi
          IFS='.' read -r major minor patch <<<"$current_version"
          new_version="$major.$minor.$patch"
          bump_type="none"
          changed="false"
          if [[ "$source_branch" == "main" ]]; then
            minor=$((minor + 1))
            patch=0
            new_version="$major.$minor.$patch"
            bump_type="minor"
          elif [[ "$source_branch" == hotfix/* ]]; then
            patch=$((patch + 1))
            new_version="$major.$minor.$patch"
            bump_type="patch"
          else
            echo "Branch ${source_branch} does not require a version bump."
          fi
          if [[ "$new_version" != "$current_version" ]]; then
            echo "$new_version" > version
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add version
            if ! git diff --cached --quiet; then
              git commit -m "chore: bump version to $new_version"
              git push origin "HEAD:${target_ref}"
              echo "Version bumped from $current_version to $new_version ($bump_type)."
              changed="true"
            else
              echo "No changes detected after bump."
            fi
          else
            echo "Version remains $new_version."
          fi
          {
            echo "new_version=$new_version"
            echo "changed=$changed"
            echo "branch=$source_branch"
            echo "bump_type=$bump_type"
            echo "target_ref=$target_ref"
          } >> "$GITHUB_OUTPUT"

      - name: Apply release label to associated PRs
        if: steps.bump_version.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const newVersion = '${{ steps.bump_version.outputs.new_version }}';
            if (!newVersion) {
              core.info('No new version detected, skipping label creation.');
              return;
            }
            const labelName = `release: ${newVersion}`;
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
                return true;
              } catch (error) {
                if (error.status === 404) {
                  try {
                    await github.rest.issues.createLabel({
                      ...context.repo,
                      name: labelName,
                      color: labelColor,
                      description: `Release ${newVersion}`,
                    });
                    return true;
                  } catch (creationError) {
                    if (creationError.status === 403) {
                      core.warning(`Insufficient permissions to create label "${labelName}". Skipping step.`);
                      return false;
                    }
                    throw creationError;
                  }
                }
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to access label "${labelName}". Skipping step.`);
                  return false;
                }
                throw error;
              }
            }
            const labelAvailable = await ensureLabelExists();
            if (!labelAvailable) {
              return;
            }
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: [labelName],
                });
                core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
              } catch (error) {
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to label PR #${pr.number}, skipping.`);
                  continue;
                }
                throw error;
              }
            }

  generate-changelog:
    name: Generate Changelog
    needs: bump-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      SOURCE_BRANCH: ${{ needs.bump-version.outputs.branch }}
      TARGET_REF: ${{ needs.bump-version.outputs.target_ref }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Prepare changelog entry
        id: changelog
        env:
          DESCRIPTION_PATH: scripts/changelog/description.txt
        run: |
          set -euo pipefail
          branch="${SOURCE_BRANCH:-${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}}"
          target_ref="${TARGET_REF:-${GITHUB_REF_NAME:-${GITHUB_HEAD_REF}}}"
          if [[ -z "$target_ref" ]]; then
            target_ref="${GITHUB_REF_NAME:-${GITHUB_HEAD_REF:-$branch}}"
          fi
          echo "Detected branch: ${branch}"
          echo "Target ref: ${target_ref}"
          if [[ ! -f "version" ]]; then
            echo "Version file not found." >&2
            exit 1
          fi
          new_version=$(tr -d '\n\r ' < version)
          if [[ -z "$new_version" ]]; then
            echo "Version file is empty." >&2
            exit 1
          fi
          hotfix_arg=()
          if [[ "$branch" == hotfix/* ]]; then
            hotfix_arg=(--hotfix)
          fi
          if [[ ! -s "$DESCRIPTION_PATH" ]]; then
            echo "Description file is empty. Populate ${DESCRIPTION_PATH} before running the workflow." >&2
            exit 1
          fi
          python scripts/changelog/generate_changelog.py --clear-description-file "${hotfix_arg[@]}"
          changed="false"
          if ! git diff --exit-code --quiet changelog.md "$DESCRIPTION_PATH"; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add changelog.md "$DESCRIPTION_PATH"
            if ! git diff --cached --quiet; then
              git commit -m "docs: update changelog for ${new_version}"
              git push origin "HEAD:${target_ref}"
              changed="true"
              echo "Changelog updated and pushed for ${new_version}."
            fi
          else
            echo "No changelog updates detected."
          fi
          {
            echo "changed=$changed"
            echo "branch=$branch"
            echo "new_version=$new_version"
          } >> "$GITHUB_OUTPUT"

      - name: Extract changelog metadata
        run: |
          set -euo pipefail
          python <<'PY'
          import json
          import re
          from pathlib import Path

          changelog_path = Path("changelog.md")
          if not changelog_path.exists():
              raise SystemExit("changelog.md not found after generation.")
          lines = changelog_path.read_text(encoding="utf-8").splitlines()
          entry_lines: list[str] = []
          capture = False
          for line in lines:
              if not capture:
                  if line.startswith("## "):
                      capture = True
                      entry_lines.append(line)
                  continue
              if line.startswith("## "):
                  break
              entry_lines.append(line)
          if not entry_lines:
              raise SystemExit("Failed to locate latest changelog entry.")
          header = entry_lines[0]
          match = re.search(r"(\d+\.\d+\.\d+)", header)
          if not match:
              raise SystemExit(f"Unable to parse version from header: {header}")
          version = match.group(1)
          description_lines: list[str] = []
          collecting_description = False
          for line in entry_lines[1:]:
              if line.strip() == "### Описание":
                  collecting_description = True
                  continue
              if line.startswith("### "):
                  collecting_description = False
              if collecting_description:
                  description_lines.append(line)
          description = "\n".join(description_lines).strip()
          if not description:
              description = "Описание отсутствует."
          payload = {"version": version, "description": description}
          Path("release_info.json").write_text(
              json.dumps(payload, ensure_ascii=False),
              encoding="utf-8",
          )
          message = f"Релиз {version}"
          if description:
              message = f"{message}\n\n{description}"
          Path("release_message.txt").write_text(message, encoding="utf-8")
          PY

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog-entry
          path: |
            release_info.json
            release_message.txt
          retention-days: 7

      - name: Apply changelog label to associated PRs
        if: steps.changelog.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = 'changelog updated';
            const labelColor = '5319E7';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
                return true;
              } catch (error) {
                if (error.status === 404) {
                  try {
                    await github.rest.issues.createLabel({
                      ...context.repo,
                      name: labelName,
                      color: labelColor,
                      description: 'Changelog entry generated automatically',
                    });
                    return true;
                  } catch (creationError) {
                    if (creationError.status === 403) {
                      core.warning(`Insufficient permissions to create label "${labelName}". Skipping step.`);
                      return false;
                    }
                    throw creationError;
                  }
                }
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to access label "${labelName}". Skipping step.`);
                  return false;
                }
                throw error;
              }
            }
            const labelAvailable = await ensureLabelExists();
            if (!labelAvailable) {
              return;
            }
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: [labelName],
                });
                core.info(`Label "${labelName}" applied to PR #${pr.number}.`);
              } catch (error) {
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to label PR #${pr.number}, skipping.`);
                  continue;
                }
                throw error;
              }
            }

  publish-docker-image:
    name: Publish Docker Image
    needs:
      - bump-version
      - generate-changelog
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Compute Docker image coordinates
        id: image_meta
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          if [ -z "${DOCKERHUB_USERNAME}" ]; then
            echo "Docker Hub username secret is empty." >&2
            exit 1
          fi
          username=$(echo "${DOCKERHUB_USERNAME}" | tr '[:upper:]' '[:lower:]')
          repo=$(echo "${REPO_NAME}" | tr '[:upper:]' '[:lower:]')
          echo "username=${username}" >> "$GITHUB_OUTPUT"
          echo "repository=${repo}" >> "$GITHUB_OUTPUT"
          echo "image=${username}/${repo}" >> "$GITHUB_OUTPUT"

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ format('{0}:{1}', steps.image_meta.outputs.image, needs.bump-version.outputs.new_version) }}

      - name: Apply docker label to associated PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = '${{ needs.bump-version.outputs.new_version }}';
            if (!version) {
              core.info('Version is not available, skipping docker label application.');
              return;
            }
            const repositoryName = '${{ steps.image_meta.outputs.repository }}';
            const username = '${{ steps.image_meta.outputs.username }}';
            const imageTag = `${username}/${repositoryName}:${version}`;
            const labelName = 'docker image published';
            const labelColor = '0E8A16';
            async function ensureLabelExists() {
              try {
                await github.rest.issues.getLabel({
                  ...context.repo,
                  name: labelName,
                });
                return true;
              } catch (error) {
                if (error.status === 404) {
                  try {
                    await github.rest.issues.createLabel({
                      ...context.repo,
                      name: labelName,
                      color: labelColor,
                      description: `Docker image ${imageTag} pushed`,
                    });
                    return true;
                  } catch (creationError) {
                    if (creationError.status === 403) {
                      core.warning(`Insufficient permissions to create label "${labelName}". Skipping step.`);
                      return false;
                    }
                    throw creationError;
                  }
                }
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to access label "${labelName}". Skipping step.`);
                  return false;
                }
                throw error;
              }
            }
            const labelAvailable = await ensureLabelExists();
            if (!labelAvailable) {
              return;
            }
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              ...context.repo,
              commit_sha: context.sha,
            });
            if (!prs.length) {
              core.info('No associated pull requests found for this commit.');
              return;
            }
            for (const pr of prs) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: [labelName],
                });
                core.info(`Label "${labelName}" applied to PR #${pr.number} for image ${imageTag}.`);
              } catch (error) {
                if (error.status === 403) {
                  core.warning(`Insufficient permissions to label PR #${pr.number}, skipping.`);
                  continue;
                }
                throw error;
              }
            }

  cd-prod:
    name: CD Prod Notification
    needs:
      - bump-version
      - generate-changelog
      - publish-docker-image
    if: needs.bump-version.outputs.changed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Download changelog artifact
        uses: actions/download-artifact@v4
        with:
          name: changelog-entry
          path: changelog_artifact

      - name: Compose Telegram message
        env:
          CHAT_ID: ${{ secrets.TG_PROD_CHAT_ID }}
        run: |
          set -euo pipefail
          python <<'PY'
          import json
          import os
          from pathlib import Path

          artifact_dir = Path("changelog_artifact")
          info_path = artifact_dir / "release_info.json"
          message_path = artifact_dir / "release_message.txt"
          if not info_path.exists():
              raise SystemExit(f"Release info artifact missing: {info_path}")
          payload = json.loads(info_path.read_text(encoding="utf-8"))
          version = payload.get("version")
          description = payload.get("description", "")
          if not version:
              raise SystemExit("Version is missing in release info artifact.")
          chat_id = os.environ.get("CHAT_ID", "").strip()
          if not chat_id:
              raise SystemExit("Telegram chat id secret TG_PROD_CHAT_ID is not configured.")
          if message_path.exists():
              text = message_path.read_text(encoding="utf-8").strip()
          else:
              text = f"Релиз {version}"
              if description:
                  text = f"{text}\n\n{description}"
          if not text:
              text = f"Релиз {version}"
          Path("payload.json").write_text(
              json.dumps({"chat_id": chat_id, "text": text}, ensure_ascii=False),
              encoding="utf-8",
          )
          print(f"Prepared Telegram payload for release {version}.")
          PY

      - name: Send Telegram notification
        env:
          BOT_TOKEN: ${{ secrets.TG_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${BOT_TOKEN}" ]; then
            echo "Telegram bot token secret TG_TOKEN is not configured." >&2
            exit 1
          fi
          curl -sS -X POST "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -H "Content-Type: application/json" \
            -d @payload.json
